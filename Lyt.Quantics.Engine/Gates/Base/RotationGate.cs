namespace Lyt.Quantics.Engine.Gates.Base;

public class RotationGate : Gate
{
    // See: https://www.quantum-inspire.com/kbase/rotation-operators/ 
    //
    // The rotation operators are defined as:
    //
    // Rx(θ)= {  cos⁡(θ/2)    −isin⁡(θ/2)  } 
    //        {  −isin(θ/2​)  cos(θ/2​)​     } 

    // Ry(θ)=  {  cos⁡(θ/2)   −sin⁡(θ/2)   }    
    //         {  sin(θ/2​)   cos(θ/2​)    } 

    // Rz(θ)=  {  e−iθ/2     0     } 
    //         {  0          eiθ/2​ }​

    // The rotation operators are generated by exponentiation of the Pauli matrices according to
    //  exp(iAx)=cos⁡(x)I+isin⁡(x)A exp(iAx)=cos(x)I+isin(x)A  where A is one of the three
    //  Pauli Matrices.

    private readonly Matrix<Complex> matrix = Matrix<Complex>.Build.Dense(1,1);
    private readonly string captionKey = string.Empty;

    public RotationGate(GateParameters parameters)
    {
        this.Axis = parameters.Axis;
        this.Angle = parameters.Angle;
        this.IsPiDivisor = parameters.IsPiDivisor;
        this.PiDivisor = parameters.PiDivisor;
        this.IsPositive = parameters.IsPositive;
        if (this.IsPiDivisor)
        {
            this.Angle = (this.IsPositive ? 1.0 : -1.0) * Math.PI / this.PiDivisor;
            this.AngleParameterCaption =
                this.PiDivisor == 1 ?
                    string.Format("{0}π", this.IsPositive ? "+" : "-") :
                    string.Format("{0}π/{1}", this.IsPositive ? "+" : "-", this.PiDivisor);
        }
        else
        {
            this.AngleParameterCaption = this.Angle.ToString("F2");
        }
         

        double half = this.Angle / 2.0;
        double sinReal = Math.Sin(half);
        double cosReal = Math.Cos(half);
        Complex cosComplex = cosReal;
        Complex sinComplex = sinReal;
        Complex iotaSin = new(0, sinReal);

        this.matrix = Matrix<Complex>.Build.Sparse(2, 2, Complex.Zero);

        switch (this.Axis)
        {
            default:
            case Axis.X:
                this.matrix.At(0, 0, cosComplex);
                this.matrix.At(0, 1, -iotaSin);
                this.matrix.At(1, 0, -iotaSin);
                this.matrix.At(1, 1, cosComplex);
                this.captionKey = "Rx";
                break;

            case Axis.Y:
                this.matrix.At(0, 0, cosComplex);
                this.matrix.At(0, 1, -sinComplex);
                this.matrix.At(1, 0, sinComplex);
                this.matrix.At(1, 1, cosComplex);
                this.captionKey = "Ry";
                break;

            case Axis.Z:
                var complex = new Complex(cosReal, sinReal);
                var conjugate = new Complex(cosReal, -sinReal);
                this.matrix.At(0, 0, conjugate);
                this.matrix.At(1, 1, complex);
                this.captionKey = "Rz";
                break;
        }
    }

    public override Axis Axis { get; set; }

    public override double Angle { get; set; }

    public bool IsPiDivisor { get; private set; } = true;

    public int PiDivisor { get; private set; } = 2;

    public bool IsPositive { get; private set; } = true;

    public override string AngleParameterCaption { get; set; } = string.Empty;

    public override bool HasAngleParameter => true;

    public override Matrix<Complex> Matrix => this.matrix;

    public override string Name => "Rotation Gate";

    public override string AlternateName => "Rotation Operator";

    public override string CaptionKey => this.captionKey;

    public override GateCategory Category => GateCategory.D_Rotation;
}
